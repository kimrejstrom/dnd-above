import * as Ast from '../ast';
import { DiceGenerator } from '../generator';
import { RandomProvider } from '../random';
import { DiceResult } from './dice-result.class';
import { InterpreterError } from './error-message.class';
import { FunctionDefinitionList } from './function-definition-list.class';
import { Interpreter } from './interpreter.interface';
import { Options } from '../options.interface';
export declare class DiceInterpreter implements Interpreter<DiceResult> {
    protected functions: FunctionDefinitionList;
    protected random: RandomProvider;
    protected generator: DiceGenerator;
    protected memory: Map<string, any>;
    protected options: Options;
    constructor(functions?: FunctionDefinitionList, random?: RandomProvider, generator?: DiceGenerator, options?: Options);
    setMemory(key: string, value: any): void;
    getMemory(key: any): any;
    interpret(expression: Ast.ExpressionNode): DiceResult;
    evaluate(expression: Ast.ExpressionNode, errors: InterpreterError[]): any;
    evaluateAdd(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateSubtract(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateMultiply(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateDivide(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateModulo(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateExponent(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateNegate(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateNumber(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateDiceSides(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateDiceRoll(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateDice(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateFunction(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateString(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateGroup(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateRepeat(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateExplode(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateKeep(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateDrop(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateCritical(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateReroll(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateSort(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateSubtractFailure(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateEqual(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateGreater(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateGreaterOrEqual(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateLess(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    evaluateLessOrEqual(expression: Ast.ExpressionNode, errors: InterpreterError[]): number;
    countSuccesses(expression: Ast.ExpressionNode, subtractFailures: boolean, fails: number, errors: InterpreterError[]): number;
    countFailures(expression: Ast.ExpressionNode, subtractFailures: boolean, errors: InterpreterError[]): number;
    private countSuccessOrFailure;
    private expectChildCount;
    private evaluateComparison;
    evaluateSuccess(expression: Ast.ExpressionNode, compare: (lhs: number, rhs: number) => boolean, errors: InterpreterError[]): number;
    private findDiceOrGroupNode;
    private getSortedDiceRolls;
    private createDiceRoll;
    private createDiceRollValue;
    private wouldRollAgainForever;
}
