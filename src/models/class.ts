export interface ClassTypes {
  artificer: Class;
  barbarian: Class;
  bard: Class;
  cleric: Class;
  druid: Class;
  fighter: Class;
  monk: Class;
  paladin: Class;
  ranger: Class;
  rogue: Class;
  sorcerer: Class;
  warlock: Class;
  wizard: Class;
}

// Generated by https://quicktype.io

export interface Class {
  class: ClassElement[];
  classFeature: ClassClassFeature[];
  subclassFeature: SubclassFeature[];
}

export interface ClassElement {
  name: string;
  source: string;
  page?: number;
  srd?: boolean;
  hd: HD;
  proficiency: string[];
  spellcastingAbility?: SpellcastingAbility;
  casterProgression?: string;
  startingProficiencies: StartingProficiencies;
  startingEquipment: StartingEquipment;
  multiclassing?: Multiclassing;
  classTableGroups?: ClassTableGroup[];
  classFeatures: Array<ClassFeatureClassFeature | string>;
  subclassTitle: string;
  subclasses: ClassSubclass[];
  fluff?: Fluff[];
  isReprinted?: boolean;
  otherSources?: OtherSource[];
}

interface ClassFeatureClassFeature {
  classFeature: string;
  gainSubclassFeature: boolean;
}

export interface ClassTableGroup {
  colLabels: string[];
  rows: Array<Array<PurpleRow | number | string>>;
  title?: Title;
}

interface PurpleRow {
  type: PurpleType;
  value?: number;
  toRoll?: HD[];
}

interface HD {
  number: number;
  faces: number;
}

enum PurpleType {
  Bonus = 'bonus',
  BonusSpeed = 'bonusSpeed',
  Dice = 'dice',
}

export enum Title {
  SpellSlotsPerSpellLevel = 'Spell Slots per Spell Level',
}

interface Fluff {
  name?: string;
  type: FluffType;
  entries: Array<PurpleEntry | string>;
  source: string;
  page?: number;
}

interface PurpleEntry {
  type: FluffType;
  name?: string;
  entries: Array<FluffyEntry | string>;
  by?: string;
}

interface FluffyEntry {
  type: FluffType;
  name?: string;
  entries?: Array<TentacledEntry | string>;
  caption?: string;
  colLabels?: string[];
  colStyles?: string[];
  rows?: Array<Array<FluffyRow | string>>;
  by?: string;
}

interface TentacledEntry {
  type: FluffType;
  name?: string;
  entries?: string[];
  caption?: string;
  colLabels?: string[];
  colStyles?: string[];
  rows?: Array<Array<FluffyRow | string>>;
}

interface FluffyRow {
  type: string;
  roll: Roll;
}

interface Roll {
  exact: number;
}

enum FluffType {
  Entries = 'entries',
  Inset = 'inset',
  Quote = 'quote',
  Section = 'section',
  Table = 'table',
}

export interface Multiclassing {
  requirements: Requirements;
  proficienciesGained?: StartingProficiencies;
}

interface StartingProficiencies {
  armor?: Array<ArmorClass | ArmorEnum>;
  skills?: Skill[];
  weapons?: string[];
  tools?: string[];
}

export interface ArmorClass {
  proficiency: ArmorEnum;
  full: string;
}

export enum ArmorEnum {
  Heavy = 'heavy',
  Light = 'light',
  Medium = 'medium',
  Shields = 'shields',
}

export interface Skill {
  choose: Choose;
}

interface Choose {
  from: string[];
  count: number;
}

interface Requirements {
  dex?: number;
  wis?: number;
  or?: Or[];
  int?: number;
  cha?: number;
  str?: number;
}

interface Or {
  str: number;
  dex: number;
}

interface OtherSource {
  source: string;
  page: number;
}

export enum SpellcastingAbility {
  Cha = 'cha',
  Int = 'int',
  Wis = 'wis',
}

interface StartingEquipment {
  additionalFromBackground: boolean;
  default: string[];
  goldAlternative?: string;
  defaultData: DefaultDatum[];
}

interface DefaultDatum {
  a?: Array<Purple | string>;
  b?: Array<Purple | string>;
  _?: Array<Purple | string>;
  c?: Array<CClass | string>;
}

interface Purple {
  equipmentType?: EquipmentType;
  quantity?: number;
  item?: string;
}

enum EquipmentType {
  WeaponMartial = 'weaponMartial',
  WeaponMartialMelee = 'weaponMartialMelee',
  WeaponSimple = 'weaponSimple',
  WeaponSimpleMelee = 'weaponSimpleMelee',
}

interface CClass {
  equipmentType: EquipmentType;
}

export interface ClassSubclass {
  name: string;
  shortName: string;
  source: string;
  page?: number;
  subclassFeatures: string[];
  srd?: boolean;
  isReprinted?: boolean;
  additionalSpells?: AdditionalSpell[];
  spellcastingAbility?: SpellcastingAbility;
  casterProgression?: string;
  subclassTableGroups?: SubclassTableGroup[];
  otherSources?: OtherSource[];
}

interface AdditionalSpell {
  prepared?: { [key: string]: string[] };
  innate?: { [key: string]: string[] };
  expanded?: { [key: string]: string[] };
}

export interface SubclassTableGroup {
  subclasses: SubclassTableGroupSubclass[];
  colLabels: string[];
  rows: Array<number[]>;
  title?: Title;
}

interface SubclassTableGroupSubclass {
  name: string;
  source: string;
}

export interface ClassClassFeature {
  name: string;
  source: string;
  className: string;
  classSource: string;
  level: number;
  isClassFeatureVariant?: boolean;
  entries: Array<StickyEntry | string>;
  page?: number;
  srd?: boolean;
  otherSources?: OtherSource[];
  header?: number;
}

interface StickyEntry {
  type: StickyType;
  count?: number;
  entries?: Array<IndigoEntry | string>;
  items?: string[];
  name?: string;
  caption?: string;
  colLabels?: string[];
  colStyles?: string[];
  rows?: Array<string[]>;
  classFeature?: string;
  attributes?: SpellcastingAbility[];
}

interface IndigoEntry {
  type: TentacledType;
  classFeature?: string;
  optionalfeature?: string;
  name?: EntryName;
  attributes?: string[];
  entries?: Array<IndecentEntry | string>;
  caption?: string;
  colLabels?: string[];
  colStyles?: string[];
  rows?: Array<string[]>;
}

interface IndecentEntry {
  type: FluffType;
  name: string;
  entries: string[];
}

enum EntryName {
  Maneuver = 'Maneuver',
  Spell = 'Spell',
  TheMagicOfArtifice = 'The Magic of Artifice',
}

enum TentacledType {
  AbilityAttackMod = 'abilityAttackMod',
  AbilityDc = 'abilityDc',
  Entries = 'entries',
  Inset = 'inset',
  List = 'list',
  RefClassFeature = 'refClassFeature',
  RefOptionalfeature = 'refOptionalfeature',
  Table = 'table',
}

enum StickyType {
  AbilityDc = 'abilityDc',
  Entries = 'entries',
  InlineBlock = 'inlineBlock',
  Inset = 'inset',
  List = 'list',
  Options = 'options',
  RefClassFeature = 'refClassFeature',
  RefSubclassFeature = 'refSubclassFeature',
  Table = 'table',
}

export interface SubclassFeature {
  name: string;
  source: string;
  page?: number;
  className: string;
  classSource: string;
  subclassShortName: string;
  subclassSource: string;
  level: number;
  entries: Array<HilariousEntry | string>;
  isClassFeatureVariant?: boolean;
  header?: number;
  srd?: boolean;
  otherSources?: OtherSource[];
  type?: FluffType;
}

interface HilariousEntry {
  type: StickyType;
  subclassFeature?: string;
  entries?: Array<AmbitiousEntry | string>;
  caption?: string;
  colLabels?: string[];
  colStyles?: string[];
  rows?: Array<Array<number | string>>;
  items?: Array<ItemClass | string>;
  name?: string;
  count?: number;
  style?: string;
  attributes?: SpellcastingAbility[];
  data?: PurpleData;
  footnotes?: string[];
}

interface PurpleData {
  tableInclude: boolean;
}

interface AmbitiousEntry {
  type: IndigoType;
  subclassFeature?: string;
  name?: string;
  entries?: Array<CunningEntry | string>;
  optionalfeature?: string;
  style?: string;
  items?: ItemClass[];
  count?: number;
  caption?: string;
  colLabels?: string[];
  colStyles?: string[];
  rows?: Array<Array<number | string>>;
  data?: FluffyData;
}

interface FluffyData {
  isRequiredOption: boolean;
}

interface CunningEntry {
  type: TentacledType;
  name?: EntryName;
  attributes?: string[];
  optionalfeature?: string;
  items?: Array<ItemClass | string>;
  style?: string;
}

interface ItemClass {
  type: ItemType;
  name: string;
  entry: string;
}

enum ItemType {
  Item = 'item',
}

enum IndigoType {
  Entries = 'entries',
  List = 'list',
  Options = 'options',
  RefOptionalfeature = 'refOptionalfeature',
  RefSubclassFeature = 'refSubclassFeature',
  Table = 'table',
}
